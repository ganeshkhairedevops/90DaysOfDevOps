# Day 07 ‚Äì Linux File System Hierarchy & Scenario Practice

Today I focused on understanding where things live in Linux
and how to approach real troubleshooting scenarios logically.

---

## üîπ Part 1: Linux File System Hierarchy

### / (root)
- Starting point of the entire Linux filesystem
- All directories exist under this
- I would use this when navigating system-wide paths

Command:
ls -l /

Observation:
- Directories like bin, etc, home, var are present

---

### /home
- Contains home directories for normal users
- Each user stores personal files here
- I would use this when checking user-specific files or scripts

Command:
ls -l /home

Observation:
- Found my user directory

---

### /root
- Home directory for the root user
- Only accessible by root
- I would use this when logged in as root for admin tasks

Command:
ls -l /root

Observation:
- Root-specific config files present

---

### /etc
- Stores system and application configuration files
- Most services read configs from here
- I would use this when debugging service configuration issues

Command:
ls -l /etc | head

Observation:
- Found files like hostname, hosts, ssh

---

### /var/log
- Contains log files generated by services and system
- Most important directory for troubleshooting
- I would use this first when debugging issues

Command:
ls -l /var/log

Observation:
- Logs for auth, syslog, journal present

---

### /tmp
- Used for temporary files
- Cleared automatically on reboot
- I would use this for testing or temporary storage

Command:
ls -l /tmp

Observation:
- Temporary files present

---

### /bin
- Essential system commands like ls, cp, mv
- Required for system boot
- I would use this when basic commands are missing

Command:
ls -l /bin | head

---

### /usr/bin
- User-level command binaries
- Most applications live here
- I would use this to find installed tools

Command:
ls -l /usr/bin | head

---

### /opt
- Optional or third-party applications
- Common for custom installs
- I would use this when apps are installed manually

Command:
ls -l /opt

---

## üîπ Hands-on Checks

du -sh /var/log/* 2>/dev/null | sort -h | tail -5

cat /etc/hostname

ls -la ~

---

## üîπ Part 2: Scenario-Based Practice

### Scenario 1: Service Not Starting

Step 1:
systemctl status myapp
Why: Check if service is failed or inactive

Step 2:
journalctl -u myapp -n 50
Why: Review recent error logs

Step 3:
systemctl is-enabled myapp
Why: Verify if service starts on boot

Step 4:
systemctl restart myapp
Why: Attempt controlled restart after checks

---

### Scenario 2: High CPU Usage

Step 1:
top
Why: See live CPU usage

Step 2:
ps aux --sort=-%cpu | head -10
Why: Identify top CPU-consuming processes

Step 3:
ps -fp <PID>
Why: Understand process details

---

### Scenario 3: Finding Service Logs (docker)

Step 1:
systemctl status docker
Why: Confirm service status

Step 2:
journalctl -u docker -n 50
Why: View recent logs

Step 3:
journalctl -u docker -f
Why: Follow logs in real time

---

### Scenario 4: File Permission Issue

Step 1:
ls -l /home/user/backup.sh
Why: Check file permissions

Step 2:
chmod +x /home/user/backup.sh
Why: Add execute permission

Step 3:
ls -l /home/user/backup.sh
Why: Verify permission change

Step 4:
./backup.sh
Why: Test script execution

---

## üìù What I Learned
- Logs and configs live in predictable locations
- Troubleshooting should follow a clear sequence
- Observe first, then act
